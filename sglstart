#!/bin/bash
# -*- mode: sh; coding: utf-8-unix -*-

# 本コマンドで VolFs ファイルシステム配下のファイルを起動した際には、Windows の
# %TEMP% 環境変数に設定されているディレクトリ配下に作業ディレクトリを作成し、
# その作業ディレクトリにファイルを複写した後、起動するようにしています。
# この作業ディレクトリは自動消去されるように仕組みを組み込んではいますが、消去
# 処理が完了する前に bash.exe のコンソールを終了してしまうと、消去漏れが発生して
# しまいます。このため、定期的に作業ディレクトリを消去することをお勧めします。
# 作業ディレクトリを消去するためのコマンドは、本コマンドに -c オプションを指定
# して実行すると表示されます。表示されるコマンドに問題がなければ、パイプで sh に
# 通すことで実行することができます。本コマンド内で直接削除処理を実行したい場合
# は、clean_all 関数内を修正することで対応可能です。

# Windows版Python のコマンドを絶対パスで指定する
python_command='C:\Users\<username>\AppData\Local\Programs\Python\Python36-32\python.exe'

# Keyhac のインストールパスを指定する（最後の \ は不要）
keyhac_dir='C:\keyhac'

source wslcommon
command_name=$(basename "$0")

function usage_exit() {
    cat << EOF >&2
Usage: $command_name file
       $command_name -c
       $command_name -h
EOF
    exit 1
}

temp_win_path=$(cmd echo %TEMP%)"\\$command_name"
temp_wsl_path=$(wslpath "$temp_win_path")

function clean_all() {
    # rm -rf "$temp_wsl_path"
    echo "rm -rf \"$temp_wsl_path\""
    exit 0
}

while getopts :ch opt; do
    case $opt in
        c)
            clean_all
            ;;
        h)
            usage_exit
            ;;
        \?)
            usage_exit
            ;;
    esac
done

shift $(($OPTIND - 1))

if [ $# -ne 1 ]; then
    usage_exit
fi

function run() {
    (
        cd "$userprofile_wsl_path"
        command=$(wslpath "$1")
        shift
        "$command" "$@"
    )
}

function clean() {
    {
        # rm -rf $working_dir とする方法もあるが、安全のため以下のとおりの処理としている
        rm -f "$working_file"
        rmdir "$working_dir"
    } 2> /dev/null
}

function message() {
    echo "$command_name: $1" >&2
    exit 1
}

# ターゲットファイルが存在するか？
if [ -e "$1" ]; then
    wsl_path=$(readlink -m -- "$1")

    if [ -f "$wsl_path" ]; then
        file_name=$(basename "$wsl_path")

        # ウィンドウのタイトルにファイル名の文字列を含むものがあればポップアップする
        echo '
import sys
import os.path
import re
import time
import importlib.abc

# Keyhac のインストールパスを指定する
keyhac_dir = r"'"${keyhac_dir}"'\\"

sys.path.append(keyhac_dir + "library.zip")
sys.path.append(keyhac_dir + "lib")

class CustomPydFinder(importlib.abc.MetaPathFinder):
    def find_module(self, fullname, path=None):
        pyd_filename_body = fullname.split(".")[-1]
        pyd_fullpath = os.path.exists(keyhac_dir + "lib\\" + pyd_filename_body + ".pyd")
        if pyd_fullpath:
            for importer in sys.meta_path:
                if isinstance(importer, self.__class__):
                    continue
                loader = importer.find_module(fullname, None)
                if loader:
                    return loader

sys.meta_path.append(CustomPydFinder())

import pyauto

def popWindow(wnd, file):
    global is_opened

    base = re.sub("\.[^.]+$", "", file)
    title =  wnd.getText()

    if wnd.isVisible() and not wnd.getOwner() and wnd.getClassName() != "Emacs" and \
       (re.search("(^| )" + re.escape(file) + "( |$)", title) or \
        re.search("(^| )" + re.escape(base) + "( |$)", title)):

        # ポップアップするウィンドウにフォーカスが移らないことの対策
        # if wnd.isMinimized(): # ← 対策前の設定
        #     wnd.restore()     # ← 対策前の設定
        wnd.minimize()
        wnd.restore()

        wnd.getLastActivePopup().setForeground()
        is_opened = True

        return False
    return True

is_opened = False
pyauto.Window.enum(popWindow, sys.argv[1])

if is_opened:
    sys.exit(0)
else:
    sys.exit(1)
' | run "$python_command" - "$file_name"

        # ウィンドウのポップアップを行ったか？
        if [ $? -eq 0 ]; then
            exit 0
        fi
    fi

    # https://opcdiary.net/?p=32284

    # ターゲットファイルが DrvFs ファイルシステム上にあるか？
    if check_drvfs "$wsl_path"; then

        # そのまま開く。
        win_path=$(winpath "$wsl_path")
        start "$win_path"
    else
        # ターゲットファイルが VolFs 等 DrvFs 以外のファイルシステム上にある場合の処理

        # 通常ファイルか？
        if [ -f "$wsl_path" ]; then

            # Windows の %TEMP% フォルダ内に作業ディレクトリを作成し、その下に読み込み専用でファイル
            # をコピーし、そのファイルを開く。作業ディレクトリ配下は、消せるまで一分ごとに消去処理を
            # 繰り返す。

            mkdir -p "$temp_wsl_path" 2> /dev/null

            if [ $? -eq 0 ]; then
                working_dir=$(mktemp -d -p "$temp_wsl_path" 2> /dev/null)

                if [ $? -eq 0 ]; then
                    trap '(sleep 60; until clean; do sleep 60; done) &' 0

                    cp "$wsl_path" "$working_dir"
                    working_file=$(echo "$working_dir"/*)
                    chmod a-wx "$working_file"
                    win_path=$(winpath "$working_file")

                    # 当初 start に /wait オプションを入れていたが、起動したアプリケーションにフォーカス
                    # が移らない原因となっていたため、オプションを外すこととした。
                    start "$win_path"
                else
                    message '作業ディレクトリの作成に失敗しました'
                fi
            else
                message '作業ディレクトリの作成に失敗しました'
            fi

        # ディレクトリか？
        elif [ -d "$wsl_path" ]; then
            message 'DrvFs ファイルシステム上のフォルダ以外は開くことができません'

        # スペシャルファイル等のその他のファイルか？
        else
            message '指定したファイルは開くことができません'
        fi
    fi
else
    # ターゲットファイルが存在しない場合（コマンドや URL が指定された場合）は、そのまま開く。
    start "$1"
fi
